'use strict';

var pouchdbBinaryUtils = require('pouchdb-binary-utils');
var pouchdbAdapterUtils = require('pouchdb-adapter-utils');
var pouchdbMd5 = require('pouchdb-md5');
var pouchdbUtils = require('pouchdb-utils');
var pouchdbErrors = require('pouchdb-errors');
var pouchdbMerge = require('pouchdb-merge');

const IDB_NULL = Number.MIN_SAFE_INTEGER;
const IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;
const IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;

// These are the same as below but without the global flag
// we want to use RegExp.test because it's really fast, but the global flag
// makes the regex const stateful (seriously) as it walked through all instances
const TEST_KEY_INVALID = /^[^a-zA-Z$]|[^a-zA-Z0-9$]+/;
const TEST_PATH_INVALID = /\\.|(^|\.)[^a-zA-Z$]|[^a-zA-Z0-9$.]+/;
function needsSanitise(name, isPath) {
  if (isPath) {
    return TEST_PATH_INVALID.test(name);
  } else {
    return TEST_KEY_INVALID.test(name);
  }
}

//
// IndexedDB only allows valid JS names in its index paths, whereas JSON allows
// for any string at all. This converts invalid JS names to valid ones, to allow
// for them to be indexed.
//
// For example, "foo-bar" is a valid JSON key, but cannot be a valid JS name
// (because that would be read as foo minus bar).
//
// Very high level rules for valid JS names are:
//  - First character cannot start with a number
//  - Otherwise all characters must be be a-z, A-Z, 0-9, or $.
//  - Underscores (_) are encoded even though legal, to avoid collisions with
//    encoded illegal characters
//  - We allow . unless the name represents a single field, as that represents
//    a deep index path.
// See: https://www.w3.org/TR/IndexedDB/#key-path-construct
//
// This is more aggressive than it needs to be, but also simpler.
//
const KEY_INVALID = new RegExp(TEST_KEY_INVALID.source, 'g');
const PATH_INVALID = new RegExp(TEST_PATH_INVALID.source, 'g');
const SLASH = '\\'.charCodeAt(0);
const IS_DOT = '.'.charCodeAt(0);

function sanitise(name, isPath) {
  const correctCharacters = function (match) {
    let good = '';
    for (let i = 0; i < match.length; i++) {
      const code = match.charCodeAt(i);
      // If you're sanitising a path, a slash character is there to be interpreted
      // by whatever parses the path later as "escape the next thing".
      //
      // e.g., if you want to index THIS string:
      //   {"foo": {"bar.baz": "THIS"}}
      // Your index path would be "foo.bar\.baz".

      if (code === IS_DOT && isPath && i === 0) {
        good += '.';
      } else if (code === SLASH && isPath) {
        continue;
      } else {
        good += '_c' + code + '_';
      }
    }
    return good;
  };

  if (isPath) {
    return name.replace(PATH_INVALID, correctCharacters);
  } else {
    return name.replace(KEY_INVALID, correctCharacters);
  }
}

function needsRewrite(data) {
  for (const key of Object.keys(data)) {
    if (needsSanitise(key)) {
      return true;
    } else if (data[key] === null || typeof data[key] === 'boolean') {
      return true;
    } else if (typeof data[key] === 'object') {
      return needsRewrite(data[key]);
    }
  }
}

function rewrite(data) {
  if (!needsRewrite(data)) {
    return false;
  }

  const isArray = Array.isArray(data);
  const clone = isArray
    ? []
    : {};

  Object.keys(data).forEach(function (key) {
    const safeKey = isArray ? key : sanitise(key);

    if (data[key] === null) {
      clone[safeKey] = IDB_NULL;
    } else if (typeof data[key] === 'boolean') {
      clone[safeKey] = data[key] ? IDB_TRUE : IDB_FALSE;
    } else if (typeof data[key] === 'object') {
      clone[safeKey] = rewrite(data[key]);
    } else {
      clone[safeKey] = data[key];
    }
  });

  return clone;
}

const DOC_STORE = 'docs';
const META_LOCAL_STORE = 'meta';

function idbError(callback) {
  return function (evt) {
    let message = 'unknown_error';
    if (evt.target && evt.target.error) {
      message = evt.target.error.name || evt.target.error.message;
    }
    callback(pouchdbErrors.createError(pouchdbErrors.IDB_ERROR, message, evt.type));
  };
}

function processAttachment(name, src, doc, isBinary, attachmentFormat) {

  delete doc._attachments[name].stub;

  if (attachmentFormat === 'base64') {
    if (isBinary) {
      const att = src.attachments[doc._attachments[name].digest];
      doc._attachments[name].data = pouchdbBinaryUtils.base64StringToBlobOrBuffer(att.data, att.content_type);
    } else {
      doc._attachments[name].data =
        src.attachments[doc._attachments[name].digest].data;
    }
    delete doc._attachments[name].length;
    return Promise.resolve();
  }

  if (isBinary) {
    doc._attachments[name].data =
      src.attachments[doc._attachments[name].digest].data;
    return Promise.resolve();
  }

  return new Promise(function (resolve) {
    const data = src.attachments[doc._attachments[name].digest].data;
    pouchdbBinaryUtils.readAsBinaryString(data, function (binString) {
      doc._attachments[name].data = pouchdbBinaryUtils.btoa(binString);
      delete doc._attachments[name].length;
      resolve();
    });
  });
}

function rawIndexFields(ddoc, viewName) {
  // fields are an array of either the string name of the field, or a key value
  const fields = ddoc.views[viewName].options &&
                 ddoc.views[viewName].options.def &&
                 ddoc.views[viewName].options.def.fields || [];

  // Either ['foo'] or [{'foo': 'desc'}]
  return fields.map(function (field) {
    if (typeof field === 'string') {
      return field;
    } else {
      return Object.keys(field)[0];
    }
  });
}

/**
 * true if the view is has a "partial_filter_selector".
 */
function isPartialFilterView(ddoc, viewName) {
  return viewName in ddoc.views &&
    ddoc.views[viewName].options &&
    ddoc.views[viewName].options.def &&
    ddoc.views[viewName].options.def.partial_filter_selector;
}

function naturalIndexName(fields) {
  return '_find_idx/' + fields.join('/');
}

/**
 * Convert the fields the user gave us in the view and convert them to work for
 * indexeddb.
 *
 * fields is an array of field strings. A field string could be one field:
 *   'foo'
 * Or it could be a json path:
 *   'foo.bar'
 */
function correctIndexFields(fields) {
  // Every index has to have deleted at the front, because when we do a query
  // we need to filter out deleted documents.
  return ['deleted'].concat(
    fields.map(function (field) {
      if (['_id', '_rev', '_deleted', '_attachments'].includes(field)) {
        // These properties are stored at the top level without the underscore
        return field.substr(1);
      } else {
        // The custom document fields are inside the `data` property
        return 'data.' + sanitise(field, true);
      }
    })
  );
}

//
// Core PouchDB schema version. Increment this if we, as a library, want to make
// schema changes in indexeddb. See upgradePouchDbSchema()
//
const POUCHDB_IDB_VERSION = 2;

//
// Functions that manage a combinate indexeddb version, by combining the current
// time in millis that represents user migrations with a large multiplier that
// represents PouchDB system migrations.
//
// This lets us use the idb version number to both represent
// PouchDB-library-level migrations as well as "user migrations" required for
// when design documents trigger the addition or removal of native indexes.
//
// Given that Number.MAX_SAFE_INTEGER = 9007199254740991
//
// We can easily use the largest 2-3 digits and either allow:
//  - 900 system migrations up to 2198/02/18
//  - or 89 system migrations up to 5050/02/14
//
// This impl does the former. If this code still exists after 2198 someone send my
// descendants a Spacebook message congratulating them on their impressive genes.
//
// 9007199254740991 <- MAX_SAFE_INTEGER
//   10000000000000 <- 10^13
//    7199254740991 <- 2198-02-18T16:59:00.991Z
//
const versionMultiplier = Math.pow(10, 13);
function createIdbVersion() {
  return (versionMultiplier * POUCHDB_IDB_VERSION) + new Date().getTime();
}
function getPouchDbVersion(version) {
  return Math.floor(version / versionMultiplier);
}

function maintainNativeIndexes(openReq, reject) {
  const docStore = openReq.transaction.objectStore(DOC_STORE);
  const ddocsReq = docStore.getAll(IDBKeyRange.bound('_design/', '_design/\uffff'));

  ddocsReq.onsuccess = function (e) {
    const results = e.target.result;
    const existingIndexNames = Array.from(docStore.indexNames);

    // NB: the only thing we're supporting here is the declared indexing
    // fields nothing more.
    const expectedIndexes = results.filter(function (row) {
      return row.deleted === 0 && row.revs[row.rev].data.views;
    }).map(function (row) {
      return row.revs[row.rev].data;
    }).reduce(function (indexes, ddoc) {
      return Object.keys(ddoc.views).reduce(function (acc, viewName) {
        const fields = rawIndexFields(ddoc, viewName);

        if (fields && fields.length > 0) {
          acc[naturalIndexName(fields)] = correctIndexFields(fields);
        }

        return acc;
      }, indexes);
    }, {});

    const expectedIndexNames = Object.keys(expectedIndexes);

    // Delete any indexes that aren't system indexes or expected
    const systemIndexNames = ['seq', 'deleted,id'];
    existingIndexNames.forEach(function (index) {
      if (systemIndexNames.indexOf(index) === -1  && expectedIndexNames.indexOf(index) === -1) {
        docStore.deleteIndex(index);
      }
    });

    // Work out which indexes are missing and create them
    const newIndexNames = expectedIndexNames.filter(function (ei) {
      return existingIndexNames.indexOf(ei) === -1;
    });

    try {
      newIndexNames.forEach(function (indexName) {
        docStore.createIndex(indexName, expectedIndexes[indexName]);
      });
    } catch (err) {
      reject(err);
    }
  };
}

function upgradePouchDbSchema(dbName, db, tx, pouchdbVersion) {
  if (pouchdbVersion < 1) {
    const docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});
    docStore.createIndex('seq', 'seq', {unique: true});

    db.createObjectStore(META_LOCAL_STORE, {keyPath: 'id'});
  }

  if (pouchdbVersion < 2) {
    const docStore = tx.objectStore(DOC_STORE);
    docStore.createIndex('deleted,id', [ 'deleted', 'id' ], {unique: true});
    if (dbName.includes('-mrview-')) {
      docStore.deleteIndex('seq');
    }
  }

  // Declare more PouchDB schema changes here
  // if (pouchdbVersion < 3) { .. }
}

function openDatabase(openDatabases, api, opts, resolve, reject) {
  const openReq = opts.versionChangedWhileOpen ?
    indexedDB.open(opts.name) :
    indexedDB.open(opts.name, createIdbVersion());

  openReq.onupgradeneeded = function (e) {
    if (e.oldVersion > 0 && e.oldVersion < versionMultiplier) {
      // This DB was created with the "idb" adapter, **not** this one.
      // For now we're going to just error out here: users must manually
      // migrate between the two. In the future, dependent on performance tests,
      // we might silently migrate
      throw new Error('Incorrect adapter: you should specify the "idb" adapter to open this DB');
    } else if (e.oldVersion === 0 && e.newVersion < versionMultiplier) {
      // Firefox still creates the database with version=1 even if we throw,
      // so we need to be sure to destroy the empty database before throwing
      indexedDB.deleteDatabase(opts.name);
      throw new Error('Database was deleted while open');
    }

    const tx = e.target.transaction;
    const db = e.target.result;

    const pouchdbVersion = getPouchDbVersion(e.oldVersion);
    upgradePouchDbSchema(opts.name, db, tx, pouchdbVersion);
    maintainNativeIndexes(openReq, reject);

    if (pouchdbVersion < 2) {
      const docStore = openReq.transaction.objectStore(DOC_STORE);
      const metaStore = openReq.transaction.objectStore(META_LOCAL_STORE);

      const allDocsReq = docStore.openCursor();
      allDocsReq.onsuccess = event => {
        const cursor = event.target.result;
        if (!cursor) {
          return;
        }

        const doc = cursor.value;

        if (!pouchdbAdapterUtils.isLocalId(doc.id)) {
          return cursor.continue();
        }

        // Move _local/ docs to the META_LOCAL_STORE
        metaStore.put(doc).onsuccess = () => {
          cursor.delete(doc).onsuccess = () => {
            cursor.continue();
          };
        };
      };
    }
  };

  openReq.onblocked = function (e) {
      // AFAICT this only occurs if, after sending `onversionchange` events to
      // all other open DBs (ie in different tabs), there are still open
      // connections to the DB. In this code we should never see this because we
      // close our DBs on these events, and all DB interactions are wrapped in
      // safely re-opening the DB.
      console.error('onblocked, this should never happen', e);
  };

  openReq.onsuccess = function (e) {
    const idb = e.target.result;

    idb.onabort = function (e) {
      console.error('Database has a global failure', e.target.error);
      delete openDatabases[opts.name];
      idb.close();
    };

    // In IndexedDB you can only change the version, and thus the schema, when you are opening the database.
    // versionChangedWhileOpen means that something else outside of our control has likely updated the version.
    // One way this could happen is if you open multiple tabs, as the version number changes each time the database is opened.
    // If we suspect this we close the db and tag it, so that next time it's accessed it reopens the DB with the current version
    // as opposed to upping the version again
    // This avoids infinite loops of version updates if you have multiple tabs open
    idb.onversionchange = function () {
      console.log('Database was made stale, closing handle');
      openDatabases[opts.name].versionChangedWhileOpen = true;
      idb.close();
    };

    idb.onclose = function () {
      console.log('Database was made stale, closing handle');
      if (opts.name in openDatabases) {
        openDatabases[opts.name].versionChangedWhileOpen = true;
      }
    };

    let metadata = {id: META_LOCAL_STORE};
    const txn = idb.transaction([META_LOCAL_STORE], 'readwrite');

    txn.oncomplete = function () {
      resolve({idb, metadata});
    };

    const metaStore = txn.objectStore(META_LOCAL_STORE);
    metaStore.get(META_LOCAL_STORE).onsuccess = function (e) {
      metadata = e.target.result || metadata;
      let changed = false;

      if (!('doc_count' in metadata)) {
        changed = true;
        metadata.doc_count = 0;
      }

      if (!('seq' in metadata)) {
        changed = true;
        metadata.seq = 0;
      }

      if (!('db_uuid' in metadata)) {
        changed = true;
        metadata.db_uuid = pouchdbUtils.uuid();
      }

      if (!('idb_attachment_format' in metadata)) {
        // There will be trouble if any browser _stops_ supporting blobs.

        const createBlobDoc = blob => ({ id:'blob-support', blob });

        pouchdbAdapterUtils.checkBlobSupport(txn, META_LOCAL_STORE, createBlobDoc).then(blobSupport => {
          // Unfortunate that we have to track this in both the metadata and on
          // api, but sometimes we have access to one, sometimes the other (and
          // sometimes both).  We could change function signatures in index.js
          // to make this consistent.
          api.blobSupport = metadata.idb_attachment_format = blobSupport ? 'binary' : 'base64';
          metaStore.put(metadata);
        });
      } else if (changed) {
        api.blobSupport = metadata.idb_attachment_format;
        metaStore.put(metadata);
      }
    };
  };

  openReq.onerror = function (e) {
    reject(e.target.error);
  };
}

function setup (openDatabases, api, opts) {
  if (!openDatabases[opts.name] || openDatabases[opts.name].versionChangedWhileOpen) {
    opts.versionChangedWhileOpen = openDatabases[opts.name] &&
                          openDatabases[opts.name].versionChangedWhileOpen;

    openDatabases[opts.name] = new Promise(function (resolve, reject) {
      openDatabase(openDatabases, api, opts, resolve, reject);
    });
  }

  return openDatabases[opts.name];
}

function info (metadata, callback) {
  callback(null, {
    doc_count: metadata.doc_count,
    update_seq: metadata.seq
  });
}

function get (txn, id, opts, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  txn.txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
    const doc = e.target.result;
    let rev;
    if (!opts.rev) {
      rev = (doc && doc.rev);
    } else {
      rev = opts.latest ? pouchdbMerge.latest(opts.rev, doc) : opts.rev;
    }

    if (!doc || (doc.deleted && !opts.rev) || !(rev in doc.revs)) {
      callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC, 'missing'));
      return;
    }

    const result = doc.revs[rev].data;
    result._id = doc.id;
    result._rev = rev;

    // WARNING: expecting possible old format
    // TODO: why are we passing the transaction in the context?
    //       It's not clear we ever thread these txns usefully
    callback(null, {
      doc: result,
      metadata: doc,
      ctx: txn
    });
  };
}

// _getLocal() doesn't know if opts.binary is set or not, so assume it's not.
const BINARY_ATTACHMENTS = false;

function getLocal (txn, id, api, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  txn.txn.objectStore(META_LOCAL_STORE).get(id).onsuccess = function (e) {
    const doc = e.target.result;

    if (!doc) {
      callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC, 'missing'));
      return;
    }

    const result = doc.revs[doc.rev].data;
    result._id = doc.id;
    result._rev = doc.rev;

    if (result._attachments) {
      const processing = [];
      for (const name in result._attachments) {
        processing.push(processAttachment(name, doc, result, BINARY_ATTACHMENTS, api.blobSupport));
      }
      Promise.all(processing)
        .then(() => callback(null, result))
        .catch(callback);
    } else {
      callback(null, result);
    }
  };
}

function getAttachment(docId, attachId, attachment, opts, cb) {
  if (pouchdbAdapterUtils.isLocalId(docId)) {
    cb(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC, 'missing'));
    return;
  }

  const doc = opts.metadata;
  const data = doc.attachments[attachment.digest].data;

  if (typeof data === 'string') {
    if (opts.binary) {
      cb(null, pouchdbBinaryUtils.base64StringToBlobOrBuffer(data, attachment.content_type));
    } else {
      cb(null, data);
    }
    return;
  }

  if (opts.binary) {
    return cb(null, data);
  } else {
    pouchdbBinaryUtils.readAsBinaryString(data, function (binString) {
      cb(null, pouchdbBinaryUtils.btoa(binString));
    });
  }
}

function bulkDocs (api, req, opts, metadata, dbOpts, idbChanges, callback) {

  let txn;

  // TODO: I would prefer to get rid of these globals
  let error;
  const results = [];
  const docs = [];
  let lastWriteIndex;

  const revsLimit = dbOpts.revs_limit || 1000;
  const rewriteEnabled = dbOpts.name.indexOf("-mrview-") === -1;
  const autoCompaction = dbOpts.auto_compaction;

  // We only need to track 1 revision for local documents
  function docsRevsLimit(doc) {
    return pouchdbAdapterUtils.isLocalId(doc.id) ? 1 : revsLimit;
  }

  function rootIsMissing(doc) {
    return doc.rev_tree[0].ids[1].status === 'missing';
  }

  // Reads the original doc from the store if available
  // As in allDocs with keys option using multiple get calls is the fastest way
  function fetchExistingDocs(txn, docs) {
    let fetched = 0;
    const oldDocs = {};

    function readDone(e) {
      if (e.target.result) {
        oldDocs[e.target.result.id] = e.target.result;
      }
      if (++fetched === docs.length) {
        processDocs(txn, docs, oldDocs);
      }
    }

    docs.forEach(function (doc) {
      const docStore = pouchdbAdapterUtils.isLocalId(doc.id) ? META_LOCAL_STORE : DOC_STORE;
      txn.objectStore(docStore).get(doc.id).onsuccess = readDone;
    });
  }

  function revHasAttachment(doc, rev, digest) {
    return doc.revs[rev] &&
      doc.revs[rev].data._attachments &&
      Object.values(doc.revs[rev].data._attachments).find(function (att) {
        return att.digest === digest;
      });
  }

  function processDocs(txn, docs, oldDocs) {

    docs.forEach(function (doc, i) {
      let newDoc;

      // The first document write cannot be a deletion
      if ('was_delete' in opts && !(Object.prototype.hasOwnProperty.call(oldDocs, doc.id))) {
        newDoc = pouchdbErrors.createError(pouchdbErrors.MISSING_DOC, 'deleted');

      // The first write of a document cannot specify a revision
      } else if (opts.new_edits &&
                 !Object.prototype.hasOwnProperty.call(oldDocs, doc.id) &&
                 rootIsMissing(doc)) {
        newDoc = pouchdbErrors.createError(pouchdbErrors.REV_CONFLICT);

      // Update the existing document
      } else if (Object.prototype.hasOwnProperty.call(oldDocs, doc.id)) {
        newDoc = update(txn, doc, oldDocs[doc.id]);
        // The update can be rejected if it is an update to an existing
        // revision, if so skip it
        if (newDoc == false) {
          return;
        }

      // New document
      } else {
        // Ensure new documents are also stemmed
        const merged = pouchdbMerge.merge([], doc.rev_tree[0], docsRevsLimit(doc));
        doc.rev_tree = merged.tree;
        doc.stemmedRevs = merged.stemmedRevs;
        newDoc = doc;
        newDoc.isNewDoc = true;
        newDoc.wasDeleted = doc.revs[doc.rev].deleted ? 1 : 0;
      }

      if (newDoc.error) {
        results[i] = newDoc;
      } else {
        oldDocs[newDoc.id] = newDoc;
        lastWriteIndex = i;
        write(txn, newDoc, i);
      }
    });
  }

  // Converts from the format returned by parseDoc into the new format
  // we use to store
  function convertDocFormat(doc) {

    const newDoc = {
      id: doc.metadata.id,
      rev: doc.metadata.rev,
      rev_tree: doc.metadata.rev_tree,
      revs: doc.metadata.revs || {}
    };

    newDoc.revs[newDoc.rev] = {
      data: doc.data,
      deleted: doc.metadata.deleted
    };

    return newDoc;
  }

  function update(txn, doc, oldDoc) {

    // Ignore updates to existing revisions
    if ((doc.rev in oldDoc.revs) && !opts.new_edits) {
      return false;
    }

    const isRoot = /^1-/.test(doc.rev);

    // Reattach first writes after a deletion to last deleted tree
    if (oldDoc.deleted && !doc.deleted && opts.new_edits && isRoot) {
      const tmp = doc.revs[doc.rev].data;
      tmp._rev = oldDoc.rev;
      tmp._id = oldDoc.id;
      doc = convertDocFormat(pouchdbAdapterUtils.parseDoc(tmp, opts.new_edits, dbOpts));
    }

    const merged = pouchdbMerge.merge(oldDoc.rev_tree, doc.rev_tree[0], docsRevsLimit(doc));
    doc.stemmedRevs = merged.stemmedRevs;
    doc.rev_tree = merged.tree;

    // Merge the old and new rev data
    const revs = oldDoc.revs;
    revs[doc.rev] = doc.revs[doc.rev];
    doc.revs = revs;

    doc.attachments = oldDoc.attachments;

    const inConflict = opts.new_edits && (((oldDoc.deleted && doc.deleted) ||
       (!oldDoc.deleted && merged.conflicts !== 'new_leaf') ||
       (oldDoc.deleted && !doc.deleted && merged.conflicts === 'new_branch') ||
       (oldDoc.rev === doc.rev)));

    if (inConflict) {
      return pouchdbErrors.createError(pouchdbErrors.REV_CONFLICT);
    }

    doc.wasDeleted = oldDoc.deleted;

    return doc;
  }

  function write(txn, doc, i) {

    // We copy the data from the winning revision into the root
    // of the document so that it can be indexed
    const winningRev = pouchdbMerge.winningRev(doc);
    // rev of new doc for attachments and to return it
    const writtenRev = doc.rev;
    const isLocal = pouchdbAdapterUtils.isLocalId(doc.id);

    const theDoc = doc.revs[winningRev].data;

    const isNewDoc = doc.isNewDoc;

    if (rewriteEnabled) {
      // doc.data is what we index, so we need to clone and rewrite it, and clean
      // it up for indexability
      const result = rewrite(theDoc);
      if (result) {
        doc.data = result;
        delete doc.data._attachments;
      } else {
        doc.data = theDoc;
      }
    } else {
      doc.data = theDoc;
    }

    doc.rev = winningRev;
    // .deleted needs to be an int for indexing
    doc.deleted = doc.revs[winningRev].deleted ? 1 : 0;

    // Bump the seq for every new (non local) revision written
    if (!isLocal) {
      doc.seq = ++metadata.seq;

      let delta = 0;
      // If its a new document, we wont decrement if deleted
      if (doc.isNewDoc) {
        delta = doc.deleted ? 0 : 1;
      } else if (doc.wasDeleted !== doc.deleted) {
        delta = doc.deleted ? -1 : 1;
      }
      metadata.doc_count += delta;
    }
    delete doc.isNewDoc;
    delete doc.wasDeleted;

    // If there have been revisions stemmed when merging trees,
    // delete their data
    let revsToDelete = doc.stemmedRevs || [];

    if (autoCompaction && !isNewDoc) {
      const result = pouchdbMerge.compactTree(doc);
      if (result.length) {
        revsToDelete = revsToDelete.concat(result);
      }
    }

    if (revsToDelete.length) {
      revsToDelete.forEach(function (rev) { delete doc.revs[rev]; });
    }

    delete doc.stemmedRevs;

    if (!('attachments' in doc)) {
      doc.attachments = {};
    }

    if (theDoc._attachments) {
      for (const k in theDoc._attachments) {
        const attachment = theDoc._attachments[k];
        if (attachment.stub) {
          if (!(attachment.digest in doc.attachments)) {
            error = pouchdbErrors.createError(pouchdbErrors.MISSING_STUB);
            // TODO: Not sure how safe this manual abort is, seeing
            // console issues
            txn.abort();
            return;
          }

          if (revHasAttachment(doc, writtenRev, attachment.digest)) {
            doc.attachments[attachment.digest].revs[writtenRev] = true;
          }

        } else {

          doc.attachments[attachment.digest] = attachment;
          doc.attachments[attachment.digest].revs = {};
          doc.attachments[attachment.digest].revs[writtenRev] = true;

          theDoc._attachments[k] = {
            stub: true,
            digest: attachment.digest,
            content_type: attachment.content_type,
            length: attachment.length,
            revpos: parseInt(writtenRev, 10)
          };
        }
      }
    }

    // Local documents have different revision handling
    if (isLocal && doc.deleted) {
      txn.objectStore(META_LOCAL_STORE).delete(doc.id).onsuccess = function () {
        results[i] = {
          ok: true,
          id: doc.id,
          rev: '0-0'
        };
      };
      updateSeq(i);
      return;
    }

    const docStore = isLocal ? META_LOCAL_STORE : DOC_STORE;
    txn.objectStore(docStore).put(doc).onsuccess = function () {
      results[i] = {
        ok: true,
        id: doc.id,
        rev: writtenRev
      };
      updateSeq(i);
    };
  }

  function updateSeq(i) {
    if (i === lastWriteIndex) {
      txn.objectStore(META_LOCAL_STORE).put(metadata);
    }
  }

  function preProcessAttachment(attachment) {
    if (attachment.stub) {
      return Promise.resolve(attachment);
    }

    let binData;
    if (typeof attachment.data === 'string') {
      try {
        binData = pouchdbBinaryUtils.atob(attachment.data);
      } catch (e) {
        return Promise.reject(pouchdbErrors.createError(pouchdbErrors.BAD_ARG, 'Attachment is not a valid base64 string'));
      }
      if (metadata.idb_attachment_format === 'binary') {
        attachment.data = pouchdbBinaryUtils.binaryStringToBlobOrBuffer(binData, attachment.content_type);
      }
    } else {
      binData = attachment.data;
      if (metadata.idb_attachment_format === 'base64') {
        // TODO could run these in parallel, if we cared
        return new Promise(resolve => {
          pouchdbBinaryUtils.blobOrBufferToBase64(attachment.data, function (b64) {
            attachment.data = b64;
            pouchdbMd5.binaryMd5(binData, function (result) {
              attachment.digest = 'md5-' + result;
              attachment.length = binData.size || binData.length || 0;
              resolve(attachment);
            });
          });
        });
      }
    }

    return new Promise(function (resolve) {
      pouchdbMd5.binaryMd5(binData, function (result) {
        attachment.digest = 'md5-' + result;
        attachment.length = binData.size || binData.length || 0;
        resolve(attachment);
      });
    });
  }

  function preProcessAttachments() {
    const promises = docs.map(function (doc) {
      const data = doc.revs[doc.rev].data;
      if (!data._attachments) {
        return Promise.resolve(data);
      }
      const attachments = Object.keys(data._attachments).map(function (k) {
        data._attachments[k].name = k;
        return preProcessAttachment(data._attachments[k]);
      });

      return Promise.all(attachments).then(function (newAttachments) {
        const processed = {};
        newAttachments.forEach(function (attachment) {
          processed[attachment.name] = attachment;
          delete attachment.name;
        });
        data._attachments = processed;
        return data;
      });
    });
    return Promise.all(promises);
  }

  for (let i = 0, len = req.docs.length; i < len; i++) {
    let result;
    // TODO: We should get rid of throwing for invalid docs, also not sure
    // why this is needed in idb-next and not idb
    try {
      result = pouchdbAdapterUtils.parseDoc(req.docs[i], opts.new_edits, dbOpts);
    } catch (err) {
      result = err;
    }
    if (result.error) {
      return callback(result);
    }

    // Ideally parseDoc would return data in this format, but it is currently
    // shared so we need to convert
    docs.push(convertDocFormat(result));
  }

  preProcessAttachments().then(function () {
    // We _could_ check doc ids here, and skip opening DOC_STORE if all docs are local.
    // This may marginally slow things down for local docs.  It seems pragmatic to keep
    // the code simple and optimise for calls to bulkDocs() which include non-local docs.
    api._openTransactionSafely([DOC_STORE, META_LOCAL_STORE], 'readwrite', function (err, _txn) {
      if (err) {
        return callback(err);
      }

      txn = _txn;

      txn.onabort = function () {
        callback(error || pouchdbErrors.createError(pouchdbErrors.UNKNOWN_ERROR, 'transaction was aborted'));
      };
      txn.ontimeout = idbError(callback);

      txn.oncomplete = function () {
        idbChanges.notify(dbOpts.name);
        callback(null, results);
      };

      // We would like to use promises here, but idb sucks
      fetchExistingDocs(txn, docs);
    });
  }).catch(function (err) {
    callback(err);
  });
}

function allDocsKeys(keys, docStore, allDocsInner) {
  // It's not guaranteed to be returned in right order
  const valuesBatch = new Array(keys.length);
  let count = 0;
  keys.forEach(function (key, index) {
    docStore.get(key).onsuccess = function (event) {
      if (event.target.result) {
      valuesBatch[index] = event.target.result;
      } else {
        valuesBatch[index] = {key, error: 'not_found'};
      }
      count++;
      if (count === keys.length) {
        valuesBatch.forEach(function (doc) {
            allDocsInner(doc);
        });
      }
    };
  });
}

function createKeyRange(start, end, inclusiveStart, inclusiveEnd, key, descending) {
  try {
    if (key) {
      return IDBKeyRange.only([0, key]);
    } else if (descending) {
      return IDBKeyRange.bound(end, start, !inclusiveEnd, !inclusiveStart);
    } else {
      return IDBKeyRange.bound(start, end, !inclusiveStart, !inclusiveEnd);
    }
  } catch (e) {
    return {error: e};
  }
}

function handleKeyRangeError(opts, metadata, err, callback) {
  if (err.name === "DataError" && err.code === 0) {
    // data error, start is less than end
    const returnVal = {
      total_rows: metadata.doc_count,
      offset: opts.skip,
      rows: []
    };
    /* istanbul ignore if */
    if (opts.update_seq) {
      returnVal.update_seq = metadata.seq;
    }
    return callback(null, returnVal);
  }
  callback(pouchdbErrors.createError(pouchdbErrors.IDB_ERROR, err.name, err.message));
}

function allDocs (txn, metadata, opts, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  // TODO: Weird hack, I don't like it
  if (opts.limit === 0) {
    const returnVal = {
      total_rows: metadata.doc_count,
      offset: opts.skip,
      rows: []
    };

    /* istanbul ignore if */
    if (opts.update_seq) {
      returnVal.update_seq = metadata.seq;
    }
    return callback(null, returnVal);
  }

  const results = [];
  const processing = [];

  const key = 'key' in opts ? opts.key : false;
  const keys = 'keys' in opts ? opts.keys : false;
  let skip = opts.skip || 0;
  let limit = typeof opts.limit === 'number' ? opts.limit : undefined;
  const inclusiveEnd = opts.inclusive_end !== false;
  const descending = 'descending' in opts && opts.descending ? 'prev' : null;
  const start = 'startkey' in opts ? opts.startkey : (descending ?  '\uffff' : '');
  const end   = 'endkey'   in opts ? opts.endkey   : (descending ? '' :  '\uffff');

  const docStore = txn.txn.objectStore(DOC_STORE);

  if (keys) {
    txn.txn.oncomplete = onTxnComplete;
    const allDocsInner = doc => {
      if (doc.error) {
        return results.push(doc);
      }

      const row = { id:doc.id, key:doc.id, value:{ rev:doc.rev } };

      if (doc.deleted) {
        row.value.deleted = true;
        row.doc = null;
      } else if (opts.include_docs) {
        include_doc(row, doc);
      }

      results.push(row);
    };
    return allDocsKeys(keys, docStore, allDocsInner);
  }

  let keyRange = createKeyRange([0, start], [0, end], true, inclusiveEnd, key, descending);
  if (keyRange.error) {
    return handleKeyRangeError(opts, metadata, keyRange.error, callback);
  }

  // txn.oncomplete must be set AFTER key-range-error is generated
  txn.txn.oncomplete = onTxnComplete;

  function include_doc(row, doc) {
    const docData = doc.revs[doc.rev].data;

    row.doc = docData;
    row.doc._id = doc.id;
    row.doc._rev = doc.rev;
    if (opts.conflicts) {
      const conflicts = pouchdbMerge.collectConflicts(doc);
      if (conflicts.length) {
        row.doc._conflicts = conflicts;
      }
    }
    if (opts.attachments && docData._attachments) {
      for (const name in docData._attachments) {
        processing.push(processAttachment(name, doc, row.doc, opts.binary,
            metadata.idb_attachment_format));
      }
    }
  }

  function onTxnComplete() {
    const returnVal = {
      total_rows: metadata.doc_count,
      offset: 0,
      rows: results
    };
    /* istanbul ignore if */
    if (opts.update_seq) {
      returnVal.update_seq = metadata.seq;
    }

    if (processing.length) {
      Promise.all(processing).then(function () {
        callback(null, returnVal);
      });
    } else {
      callback(null, returnVal);
    }
  }

  const dbIndex = docStore.index('deleted,id');

  if (!skip && !limit) {
    fetchResults();
  } else {
    let firstKey;
    let limitKey = limit > 0;

    dbIndex.openKeyCursor(keyRange, descending || 'next').onsuccess = (e) => {
      const cursor = e.target.result;

      if (skip) {
        if (!cursor) { return txn.txn.commit(); }
        cursor.advance(skip);
        skip = 0;
        return;
      }

      if (firstKey === undefined) {
        firstKey = cursor && cursor.key;
        if (!firstKey) { return txn.txn.commit(); }
      }

      if (limit) {
        if (limit > 1 && cursor) {
          cursor.advance(limit - 1);
          limit = undefined;
          return;
        }
        limit = undefined;
      }


      if (limitKey) {
        limitKey = cursor && cursor.key;
      }
      if (!limitKey) {
        limitKey = descending ? keyRange.lower : keyRange.upper;
      }

      keyRange = createKeyRange(firstKey, limitKey, true, inclusiveEnd, key, descending);
      if (keyRange.error) {
        txn.txn.abort();
        return handleKeyRangeError(opts, metadata, keyRange.error, callback);
      }

      fetchResults();
    };
  }

  async function fetchResults() {
    // There is a risk here with getting all results into memory - if they have multiple
    // revs, then we risk loading loads of extra data which is then discarded.  This is
    // reduced by batching.  This also loads unused data when include_docs is false.
    //
    // Current batch size is quite arbitrary, but seems like (1) more than a typical
    // result size, and (2) not so big it's likely to cause issues.
    const batchSize = 100;

    let kr = keyRange;
    do {
      kr = await fetchNextBatch(kr);
    } while (kr);
    if (descending) {
      results.reverse();
    }
    return txn.txn.commit();

    function fetchNextBatch(kr) {
      return new Promise((resolve) => {
        dbIndex.getAll(kr, batchSize).onsuccess = (e) => {
          const batch = e.target.result;
          for (let i=0; i<batch.length; ++i) {
            const doc = batch[i];
            const row = { id:doc.id, key:doc.id, value:{ rev:doc.rev } };
            if (opts.include_docs) {
              include_doc(row, doc);
            }
            results.push(row);
          }

          if (batch.length >= batchSize) {
            const lastSeenKey = [ 0, batch[batch.length-1].id ];
            const startKey = descending ? kr.upper : lastSeenKey;
            const endKey = descending ? lastSeenKey : kr.upper;
            if (startKey[1] !== endKey[1]) {
              const incEnd = descending ? false : inclusiveEnd;
              const incStart = descending ? true : false;
              return resolve(createKeyRange(startKey, endKey, incStart, incEnd, key, descending));
            }
          }
          return resolve();
        };
      });
    }
  }
}

function changes (txn, idbChanges, api, dbOpts, opts) {
  if (txn.error) {
    return opts.complete(txn.error);
  }

  if (opts.continuous) {
    const id = dbOpts.name + ':' + pouchdbUtils.uuid();
    idbChanges.addListener(dbOpts.name, id, api, opts);
    idbChanges.notify(dbOpts.name);
    return {
      cancel: function () {
        idbChanges.removeListener(dbOpts.name, id);
      }
    };
  }

  let limit = 'limit' in opts ? opts.limit : -1;
  if (limit === 0) {
    limit = 1;
  }

  const store = txn.txn.objectStore(DOC_STORE).index('seq');

  const filter = pouchdbUtils.filterChange(opts);
  let received = 0;

  let lastSeq = opts.since || 0;
  const results = [];

  const processing = [];

  function onReqSuccess(e) {
    if (!e.target.result) { return; }
    const cursor = e.target.result;
    const doc = cursor.value;
    // Overwrite doc.data, which may have been rewritten (see rewrite.js) with
    // the clean version for that rev
    doc.data = doc.revs[doc.rev].data;
    doc.data._id = doc.id;
    doc.data._rev = doc.rev;
    if (doc.deleted) {
      doc.data._deleted = true;
    }

    if (opts.doc_ids && opts.doc_ids.indexOf(doc.id) === -1) {
      return cursor.continue();
    }

    // WARNING: expecting possible old format
    const change = opts.processChange(doc.data, doc, opts);
    change.seq = doc.seq;
    lastSeq = doc.seq;
    const filtered = filter(change);

    // If its an error
    if (typeof filtered === 'object') {
      return opts.complete(filtered);
    }

    if (filtered) {
      received++;
      if (opts.return_docs) {
        results.push(change);
      }

      if (opts.include_docs && opts.attachments && doc.data._attachments) {
        const promises = [];
        for (const name in doc.data._attachments) {
          const p = processAttachment(name, doc, change.doc, opts.binary, api.blobSupport);
          // We add the processing promise to 2 arrays, one tracks all
          // the promises needed before we fire onChange, the other
          // ensure we process all attachments before onComplete
          promises.push(p);
          processing.push(p);
        }

        Promise.all(promises).then(function () {
          opts.onChange(change);
        });
      } else {
        opts.onChange(change);
      }
    }
    if (received !== limit) {
      cursor.continue();
    }
  }

  function onTxnComplete() {
    Promise.all(processing).then(function () {
      opts.complete(null, {
        results,
        last_seq: lastSeq
      });
    });
  }

  let req;
  if (opts.descending) {
    req = store.openCursor(null, 'prev');
  } else {
    req = store.openCursor(IDBKeyRange.lowerBound(opts.since, true));
  }

  txn.txn.oncomplete = onTxnComplete;
  req.onsuccess = onReqSuccess;
}

function getRevisionTree (txn, id, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  const req = txn.txn.objectStore(DOC_STORE).get(id);
  req.onsuccess = function (e) {
    if (!e.target.result) {
      callback(pouchdbErrors.createError(pouchdbErrors.MISSING_DOC));
    } else {
      callback(null, e.target.result.rev_tree);
    }
  };
}

function doCompaction (txn, id, revs, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  const docStore = txn.txn.objectStore(DOC_STORE);

  docStore.get(id).onsuccess = function (e) {
    const doc = e.target.result;

    pouchdbMerge.traverseRevTree(doc.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {
      const rev = pos + '-' + revHash;
      if (revs.indexOf(rev) !== -1) {
        opts.status = 'missing';
      }
    });

    const attachments = [];

    revs.forEach(function (rev) {
      if (rev in doc.revs) {
        // Make a list of attachments that are used by the revisions being
        // deleted
        if (doc.revs[rev].data._attachments) {
          for (const k in doc.revs[rev].data._attachments) {
            attachments.push(doc.revs[rev].data._attachments[k].digest);
          }
        }
        delete doc.revs[rev];
      }
    });

    // Attachments have a list of revisions that are using them, when
    // that list becomes empty we can delete the attachment.
    attachments.forEach(function (digest) {
      revs.forEach(function (rev) {
        delete doc.attachments[digest].revs[rev];
      });
      if (!Object.keys(doc.attachments[digest].revs).length) {
        delete doc.attachments[digest];
      }
    });

    docStore.put(doc);
  };

  txn.txn.oncomplete = function () {
    callback();
  };
}

function destroy (dbOpts, openDatabases, idbChanges, callback) {

  idbChanges.removeAllListeners(dbOpts.name);

  function doDestroy() {
    const req = indexedDB.deleteDatabase(dbOpts.name);
    req.onsuccess = function () {
      delete openDatabases[dbOpts.name];
      callback(null, {ok: true});
    };
  }

  // If the database is open we need to close it
  if (dbOpts.name in openDatabases) {
    openDatabases[dbOpts.name].then(function (res) {
      res.idb.close();
      doDestroy();
    });
  } else {
    doDestroy();
  }

}

// Adapted from
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-find/src/adapters/local/find/query-planner.js#L20-L24
// This could change / improve in the future?
const COUCH_COLLATE_LO = null;
const COUCH_COLLATE_HI = '\uffff'; // actually used as {"\uffff": {}}

// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys
// Importantly, *there is no upper bound possible* in idb. The ideal data
// structure an infinitely deep array:
//   const IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)
// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers
// because it looks nice and surely that's enough!
const IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;
const IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];

//
// TODO: this should be made offical somewhere and used by AllDocs / get /
// changes etc as well.
//
function externaliseRecord(idbDoc) {
  const doc = idbDoc.revs[idbDoc.rev].data;
  doc._id = idbDoc.id;
  doc._rev = idbDoc.rev;
  if (idbDoc.deleted) {
    doc._deleted = true;
  }

  return doc;
}

/**
 * Generates a keyrange based on the opts passed to query
 *
 * The first key is always 0, as that's how we're filtering out deleted entries.
 */
function generateKeyRange(opts) {
  function defined(obj, k) {
    return obj[k] !== void 0;
  }

  // Converts a valid CouchDB key into a valid IndexedDB one
  function convert(key, exact) {
    // The first item in every native index is doc.deleted, and we always want
    // to only search documents that are not deleted.
    // "foo" -> [0, "foo"]
    const filterDeleted = [0].concat(key);

    return filterDeleted.map(function (k) {
      // null, true and false are not indexable by indexeddb. When we write
      // these values we convert them to these constants, and so when we
      // query for them we need to convert the query also.
      if (k === null && exact) {
        // for non-exact queries we treat null as a collate property
        // see `if (!exact)` block below
        return IDB_NULL;
      } else if (k === true) {
        return IDB_TRUE;
      } else if (k === false) {
        return IDB_FALSE;
      }

      if (!exact) {
        // We get passed CouchDB's collate low and high values, so for non-exact
        // ranged queries we're going to convert them to our IDB equivalents
        if (k === COUCH_COLLATE_LO) {
          return IDB_COLLATE_LO;
        } else if (Object.prototype.hasOwnProperty.call(k, COUCH_COLLATE_HI)) {
          return IDB_COLLATE_HI;
        }
      }

      return k;
    });
  }

  // CouchDB and so PouchdB defaults to true. We need to make this explicit as
  // we invert these later for IndexedDB.
  if (!defined(opts, 'inclusive_end')) {
    opts.inclusive_end = true;
  }
  if (!defined(opts, 'inclusive_start')) {
    opts.inclusive_start = true;
  }

  if (opts.descending) {
    // Flip before generating. We'll check descending again later when performing
    // an index request
    const realEndkey = opts.startkey,
        realInclusiveEnd = opts.inclusive_start;

    opts.startkey = opts.endkey;
    opts.endkey = realEndkey;
    opts.inclusive_start = opts.inclusive_end;
    opts.inclusive_end = realInclusiveEnd;
  }

  try {
    if (defined(opts, 'key')) {
      return IDBKeyRange.only(convert(opts.key, true));
    }

    if (defined(opts, 'startkey') && !defined(opts, 'endkey')) {
      // lowerBound, but without the deleted docs.
      // [1] is the start of the deleted doc range, and we don't want to include then.
      return IDBKeyRange.bound(
        convert(opts.startkey), [1],
        !opts.inclusive_start, true
      );
    }

    if (!defined(opts, 'startkey') && defined(opts, 'endkey')) {
      return IDBKeyRange.upperBound(convert(opts.endkey), !opts.inclusive_end);
    }

    if (defined(opts, 'startkey') && defined(opts, 'endkey')) {
      return IDBKeyRange.bound(
        convert(opts.startkey),    convert(opts.endkey),
        !opts.inclusive_start, !opts.inclusive_end
      );
    }

    return IDBKeyRange.only([0]);
  } catch (err) {
    console.error('Could not generate keyRange', err, opts);
    throw Error('Could not generate key range with ' + JSON.stringify(opts));
  }
}

function getIndexHandle(pdb, fields, reject) {
  const indexName = naturalIndexName(fields);

  return new Promise(function (resolve) {
    pdb._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {
      if (err) {
        return idbError(reject)(err);
      }

      txn.onabort = idbError(reject);
      txn.ontimeout = idbError(reject);

      const existingIndexNames = Array.from(txn.objectStore(DOC_STORE).indexNames);

      if (existingIndexNames.indexOf(indexName) === -1) {
        // The index is missing, force a db restart and try again
        pdb._freshen()
          .then(function () { return getIndexHandle(pdb, fields, reject); })
          .then(resolve);
      } else {
        resolve(txn.objectStore(DOC_STORE).index(indexName));
      }
    });
  });
}

// In theory we should return something like the doc example below, but find
// only needs rows: [{doc: {...}}], so I think we can just not bother for now
// {
//   "offset" : 0,
//   "rows": [{
//     "id": "doc3",
//     "key": "Lisa Says",
//     "value": null,
//     "doc": {
//       "_id": "doc3",
//       "_rev": "1-z",
//       "title": "Lisa Says"
//     }
//   }],
//   "total_rows" : 4
// }
function query(idb, signature, opts, fallback) {
  // At this stage, in the current implementation, find has already gone through
  // and determined if the index already exists from PouchDB's perspective (eg
  // there is a design doc for it).
  //
  // If we find that the index doesn't exist this means we have to close and
  // re-open the DB to correct indexes before proceeding, at which point the
  // index should exist.

  const pdb = this;

  // Assumption, there will be only one /, between the design document name
  // and the view name.
  const parts = signature.split('/');

  return new Promise(function (resolve, reject) {
    pdb.get('_design/' + parts[0]).then(function (ddoc) {
      if (isPartialFilterView(ddoc, parts[1])) {
        // Fix for #8522
        // An IndexedDB index is always over all entries. And there is no way to filter them.
        // Therefore the normal findAbstractMapper will be used
        // for indexes with partial_filter_selector.
        return fallback(signature, opts).then(resolve, reject);
      }

      const fields = rawIndexFields(ddoc, parts[1]);
      if (!fields) {
        throw new Error('ddoc ' + ddoc._id +' with view ' + parts[1] +
          ' does not have map.options.def.fields defined.');
      }

      let skip = opts.skip;
      let limit = Number.isInteger(opts.limit) && opts.limit;

      return getIndexHandle(pdb, fields, reject)
        .then(function (indexHandle) {
          const keyRange = generateKeyRange(opts);
          const req = indexHandle.openCursor(keyRange, opts.descending ? 'prev' : 'next');

          const rows = [];
          req.onerror = idbError(reject);
          req.onsuccess = function (e) {
            const cursor = e.target.result;

            if (!cursor || limit === 0) {
              return resolve({
                rows
              });
            }

            if (skip) {
              cursor.advance(skip);
              skip = false;
              return;
            }

            if (limit) {
              limit = limit - 1;
            }

            rows.push({doc: externaliseRecord(cursor.value)});
            cursor.continue();
          };
        });
      })
      .catch(reject);
  });

}

function viewCleanup(idb, fallback) {
  // I'm not sure we have to do anything here.
  //
  // One option is to just close and re-open the DB, which performs the same
  // action. The only reason you'd want to call this is if you deleted a bunch
  // of indexes and wanted the space back immediately.
  //
  // Otherwise index cleanup happens when:
  //  - A DB is opened
  //  - A find query is performed against an index that doesn't exist but should

  // Fix for #8522
  // On views with partial_filter_selector the standard find-abstract-mapper is used.
  // Its indexes must be cleaned up.
  // Fallback is the standard viewCleanup.
  return fallback();
}

function purgeAttachments(doc, revs) {
  if (!doc.attachments) {
    // If there are no attachments, doc.attachments is an empty object
    return {};
  }

  // Iterate over all attachments and remove the respective revs
  for (let key in doc.attachments) {
    const attachment = doc.attachments[key];

    for (let rev of revs) {
      if (attachment.revs[rev]) {
        delete attachment.revs[rev];
      }
    }

    if (Object.keys(attachment.revs).length === 0) {
      delete doc.attachments[key];
    }
  }

  return doc.attachments;
}

// `purge()` expects a path of revisions in its revs argument that:
// - starts with a leaf rev
// - continues sequentially with the remaining revs of that leaf’s branch
//
// eg. for this rev tree:
// 1-9692 ▶ 2-37aa ▶ 3-df22 ▶ 4-6e94 ▶ 5-df4a ▶ 6-6a3a ▶ 7-57e5
//          ┃                 ┗━━━━━━▶ 5-8d8c ▶ 6-65e0
//          ┗━━━━━━▶ 3-43f6 ▶ 4-a3b4
//
// …if you wanted to purge '7-57e5', you would provide ['7-57e5', '6-6a3a', '5-df4a']
//
// The purge adapter implementation in `pouchdb-core` uses the helper function `findPathToLeaf`
// from `pouchdb-merge` to construct this array correctly. Since this purge implementation is
// only ever called from there, we do no additional checks here as to whether `revs` actually
// fulfills the criteria above, since `findPathToLeaf` already does these.
function purge(txn, docId, revs, callback) {
  if (txn.error) {
    return callback(txn.error);
  }

  const docStore = txn.txn.objectStore(DOC_STORE);
  const deletedRevs = [];
  let documentWasRemovedCompletely = false;
  docStore.get(docId).onsuccess = (e) => {
    const doc = e.target.result;

    // we could do a dry run here to check if revs is a proper path towards a leaf in the rev tree

    for (const rev of revs) {
      // purge rev from tree
      doc.rev_tree = pouchdbMerge.removeLeafFromTree(doc.rev_tree, rev);

      // assign new revs
      delete doc.revs[rev];
      deletedRevs.push(rev);
    }

    if (doc.rev_tree.length === 0) {
      // if the rev tree is empty, we can delete the entire document
      docStore.delete(doc.id);
      documentWasRemovedCompletely = true;
      return;
    }

    // find new winning rev
    doc.rev = pouchdbMerge.winningRev(doc);
    doc.data = doc.revs[doc.rev].data;
    doc.attachments = purgeAttachments(doc, revs);

    // finally, write the purged doc
    docStore.put(doc);
  };

  txn.txn.oncomplete = function () {
    callback(null, {
      ok: true,
      deletedRevs,
      documentWasRemovedCompletely
    });
  };
}

const ADAPTER_NAME = 'indexeddb';

// TODO: Constructor should be capitalised
const idbChanges = new pouchdbUtils.changesHandler();

// A shared list of database handles
const openDatabases = {};

function IndexeddbPouch(dbOpts, callback) {

  if (dbOpts.view_adapter) {
    console.log('Please note that the indexeddb adapter manages _find indexes itself, therefore it is not using your specified view_adapter');
  }

  const api = this;
  let metadata = {};

  // Wrapper that gives you an active DB handle. You probably want $t.
  const $ = function (fun) {
    return function () {
      const args = Array.prototype.slice.call(arguments);
      setup(openDatabases, api, dbOpts).then(function (res) {
        metadata = res.metadata;
        args.unshift(res.idb);
        fun.apply(api, args);
      }).catch(function (err) {
        const last = args.pop();
        if (typeof last === 'function') {
          last(err);
        } else {
          console.error(err);
        }
      });
    };
  };
  // the promise version of $
  const $p = function (fun) {
    return function () {
      const args = Array.prototype.slice.call(arguments);

      return setup(openDatabases, api, dbOpts).then(function (res) {
        metadata = res.metadata;
        args.unshift(res.idb);

        return fun.apply(api, args);
      });
    };
  };
  // Wrapper that gives you a safe transaction handle. It's important to use
  // this instead of opening your own transaction from a db handle got from $,
  // because in the time between getting the db handle and opening the
  // transaction it may have been invalidated by index changes.
  const $t = function (fun, stores, mode) {
    mode = mode || 'readonly';

    return function () {
      const args = Array.prototype.slice.call(arguments);
      const txn = {};
      setup(openDatabases, api, dbOpts).then(function (res) {
        metadata = res.metadata;
        txn.txn = res.idb.transaction(stores, mode);
      }).catch(function (err) {
        console.error('Failed to establish transaction safely');
        console.error(err);
        txn.error = err;
      }).then(function () {
        args.unshift(txn);
        fun.apply(api, args);
      });
    };
  };

  api._openTransactionSafely = function (stores, mode, callback) {
    $t(function (txn, callback) {
      callback(txn.error, txn.txn);
    }, stores, mode)(callback);
  };

  api._remote = false;
  api.type = function () { return ADAPTER_NAME; };

  api._id = $(function (_, cb) {
    cb(null, metadata.db_uuid);
  });

  api._info = $(function (_, cb) {
    return info(metadata, cb);
  });

  api._get = $t(get, [DOC_STORE]);
  api._getLocal = $t(function (txn, id, callback) {
    return getLocal(txn, id, api, callback);
  }, [META_LOCAL_STORE]);

  api._bulkDocs = $(function (_, req, opts, callback) {
    bulkDocs(api, req, opts, metadata, dbOpts, idbChanges, callback);
  });

  api._allDocs = $t(function (txn, opts, cb) {
    allDocs(txn, metadata, opts, cb);
  }, [DOC_STORE]);

  api._getAttachment = getAttachment;

  api._changes = $t(function (txn, opts) {
    changes(txn, idbChanges, api, dbOpts, opts);
  }, [DOC_STORE]);

  api._getRevisionTree = $t(getRevisionTree, [DOC_STORE]);
  api._doCompaction = $t(doCompaction, [DOC_STORE], 'readwrite');

  api._customFindAbstractMapper = {
    query: $p(query),
    viewCleanup: $p(viewCleanup)
  };

  api._destroy = function (opts, callback) {
    return destroy(dbOpts, openDatabases, idbChanges, callback);
  };

  api._close = $(function (db, cb) {
    delete openDatabases[dbOpts.name];
    db.close();
    cb();
  });

  // Closing and re-opening the DB re-generates native indexes
  api._freshen = function () {
    return new Promise(function (resolve) {
      api._close(function () {
        $(resolve)();
      });
    });
  };

  api._purge = $t(purge, [DOC_STORE], 'readwrite');

  // TODO: this setTimeout seems nasty, if its needed lets
  // figure out / explain why
  setTimeout(function () {
    callback(null, api);
  });
}

// TODO: this isnt really valid permanently, just being lazy to start
IndexeddbPouch.valid = function () {
  return true;
};

function index (PouchDB) {
  PouchDB.adapter(ADAPTER_NAME, IndexeddbPouch, true);
}

module.exports = index;
